const t=JSON.parse('{"key":"v-432090da","path":"/java/java-se/05_%E8%A1%A5%E5%85%85%E9%80%92%E5%BD%92.html","title":"05. 递归的定义","lang":"zh-CN","frontmatter":{"lang":"zh-CN","title":"05. 递归的定义","description":"Java的基本介绍-递归的定义","author":"景天","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/java/java-se/05_%E8%A1%A5%E5%85%85%E9%80%92%E5%BD%92.html"}],["meta",{"property":"og:site_name","content":"Index Team"}],["meta",{"property":"og:title","content":"05. 递归的定义"}],["meta",{"property":"og:description","content":"Java的基本介绍-递归的定义"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-16T02:17:19.000Z"}],["meta",{"property":"article:author","content":"景天"}],["meta",{"property":"article:modified_time","content":"2024-02-16T02:17:19.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"05. 递归的定义\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-02-16T02:17:19.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"景天\\"}]}"]]},"headers":[],"git":{"createdTime":1708049839000,"updatedTime":1708049839000,"contributors":[{"name":"LSauce","email":"ls_satan@qq.com","commits":1}]},"readingTime":{"minutes":4.41,"words":1324},"filePathRelative":"java/java-se/05_补充递归.md","localizedDate":"2024年2月16日","excerpt":"<h1> 递归的定义</h1>\\n<p>我们已经学习过方法，使用过方法了。方法体中是可以调用方法的，那么如果在方法体中调用方法自身呢？</p>\\n<p>特别的，在一个方法当中再次调用这个方法，就像故事里提到同样的故事一样，<strong>我们把方法在运行时调用自身的情况，称之为递归，又叫做递归调用。</strong></p>\\n<h1> 使用递归的注意事项</h1>\\n<p>递归的使用有很多限制，尤其要注意以下两点：</p>\\n<ol>\\n<li>合法的递归，除了要有递归体语句外，还要有递归出口。无限制的递归下去，会引发栈溢出错误（StackOverflowError）</li>\\n<li>即便是有出口的递归，递归的深度也不能超过栈空间的大小，否则仍然会报错</li>\\n</ol>"}');export{t as data};
